/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
import { Readable } from "stream";
import { Server } from "@server/types/app";
import { VideoInfo } from "./types";
import { Song } from "../../types/prisma";
const YoutubeDlWrap = require("youtube-dl-wrap");
const youtubeDlWrap = new YoutubeDlWrap(process.env.YOUTUBE_DL_LOCATION);

export const createStream = (song: Song<Server>) => {
  return youtubeDlWrap.execStream([song.url, "-f", "m4a"]) as Readable;
};

const parseVideoInfoString = (metadata: string): VideoInfo => {
  try {
    return JSON.parse(metadata) as VideoInfo;
  } catch {
    return JSON.parse(
      "[" + metadata.replace(/\n/g, ",").slice(0, -1) + "]"
    ) as VideoInfo;
  }
};

export const getVideoInfo = async (song: Song<Server>) => {
  try {
    const metadata: string = await youtubeDlWrap.execPromise([
      song.url,
      "--dump-json",
    ]);

    if (!metadata) {
      throw new Error("No metadata");
    }

    return parseVideoInfoString(metadata);
  } catch (e) {
    console.log("e", e);
  }

  return undefined;
};

const cleanTitle = (title?: string | null) => {
  if (!title) return null;
  return title
    .toLowerCase()
    .trim()
    .replace(/ *\([^)]*\) */g, "")
    .replace(/ *\[[^\]]*]/, "")
    .replace(/feat.|ft./g, "")
    .replace(/\s+/g, " ")
    .trim();
};

export const guessSongArtistAndTrack = (info: VideoInfo) => {
  const { title, artist, track, description } = info;

  // Artist and Track from metadata
  if (artist && track) {
    return { artist, track };
  }

  // Auto-generated by YouTube (Title is track and artist is creator)
  if (description.includes("Auto-generated by YouTube")) {
    return {
      artist: info.creator,
      track: title,
    };
  }

  // Artist - Track
  if (title.includes(" - ")) {
    const split = title.split(" - ");

    return { artist: split[0]?.trim() ?? null, track: cleanTitle(split[1]) };
  }

  // Artist-Track
  if (title.includes("-")) {
    const split = title.split("-");

    return { artist: split[0]?.trim() ?? null, track: cleanTitle(split[1]) };
  }

  return { artist: null, track: title };
};

const isVideoAvailable = async (song: Song<Server>) =>
  !!(await getVideoInfo(song));

export const isValidReportedBrokenSong = async (song: Song<Server>) => {
  const availableFirstCheck = await isVideoAvailable(song);

  const availableSecondCheck = await new Promise<boolean>((resolve) => {
    setTimeout(() => {
      resolve(isVideoAvailable(song));
    }, 3000);
  });

  return !availableFirstCheck && !availableSecondCheck;
};
